name: CI/CD Pipeline (Backend & Frontend → ECR → Terraform/EC2)

on:
  push:
    branches: [main]

jobs:
  test-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Install dependencies
        run: |
          cd backend
          npm ci
      - name: Run backend tests
        run: |
          cd backend
          npm test
      - name: Run backend coverage
        run: |
          cd backend
          npm run test:coverage
      - name: Upload backend coverage report
        uses: actions/upload-artifact@v4
        with:
          name: backend-coverage
          path: backend/coverage/

  push-backend:
    runs-on: ubuntu-latest
    needs: test-backend
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      - name: Verify AWS credentials and region
        run: |
          aws sts get-caller-identity
          aws ecr describe-repositories --region ${{ secrets.AWS_REGION }} || echo "ECR repo not found, will create."
      - name: Create backend ECR repository if not exists
        env:
          BACKEND_ECR_REPO: ${{ secrets.ECR_REPO_BACKEND }}
          BACKEND_ECR_URL: ${{ secrets.ECR_REPO_BACKEND }}
        run: |
          # Determine backend repo name: prefer explicit secret, else parse from ECR URL
          REPO_NAME="$BACKEND_ECR_REPO"
          if [ -z "$REPO_NAME" ] && [ -n "$BACKEND_ECR_URL" ]; then
            REPO_NAME=$(echo "$BACKEND_ECR_URL" | awk -F/ '{print $2}')
          fi
          if [ -z "$REPO_NAME" ]; then
            echo "No backend ECR repository name provided; skipping creation. Set secret ECR_REPOSITORY_BACKEND or ECR_REPO_URL.";
          else
            aws ecr describe-repositories --repository-names "$REPO_NAME" --region ${{ secrets.AWS_REGION }} || aws ecr create-repository --repository-name "$REPO_NAME" --region ${{ secrets.AWS_REGION }}
            # write resolved repository name to GITHUB_ENV for later steps
            echo "BACKEND_ECR_NAME=$REPO_NAME" >> $GITHUB_ENV
          fi
      - name: Resolve backend ECR repository URI
        run: |
          if [ -n "$BACKEND_ECR_NAME" ]; then
            REPO_URI=$(aws ecr describe-repositories --repository-names "$BACKEND_ECR_NAME" --region ${{ secrets.AWS_REGION }} --query 'repositories[0].repositoryUri' --output text)
            echo "BACKEND_IMAGE_URI=$REPO_URI" >> $GITHUB_ENV
          else
            echo "BACKEND_IMAGE_URI=" >> $GITHUB_ENV
          fi
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: Build and push backend Docker image
        env:
          FALLBACK_ECR: ${{ secrets.ECR_REPO_BACKEND }}
        run: |
          IMAGE_URI="$BACKEND_IMAGE_URI"
          if [ -z "$IMAGE_URI" ]; then
            IMAGE_URI="$FALLBACK_ECR"
          fi
          # final safe fallback: construct from account/region and a sane repo name
          if [ -z "$IMAGE_URI" ]; then
            if [ -n "${{ secrets.AWS_ACCOUNT_ID }}" ] && [ -n "${{ secrets.AWS_REGION }}" ]; then
              IMAGE_URI="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/cicd-final-backend"
              echo "No explicit repo configured; using constructed ECR URI: $IMAGE_URI"
            fi
          fi
          if [ -z "$IMAGE_URI" ]; then
            echo "No BACKEND_IMAGE_URI resolved and no fallback secret; building local image and skipping push.";
            docker build -t backend:latest ./backend
          else
            echo "Building and pushing image: $IMAGE_URI:latest"
            docker build -t "$IMAGE_URI:latest" ./backend
            docker push "$IMAGE_URI:latest"
          fi

  push-frontend:
    runs-on: ubuntu-latest
    needs: test-backend
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      - name: Verify AWS credentials and region
        run: |
          aws sts get-caller-identity
          aws ecr describe-repositories --region ${{ secrets.AWS_REGION }} || echo "ECR repo not found, will create."
      - name: Create frontend ECR repository if not exists
        env:
          FRONTEND_ECR_REPO: ${{ secrets.ECR_REPO_FRONTEND }}
          FRONTEND_ECR_URL: ${{ secrets.ECR_REPO_FRONTEND }}
        run: |
          # Determine frontend repo name: prefer explicit secret, else parse from ECR URL
          REPO_NAME="$FRONTEND_ECR_REPO"
          if [ -z "$REPO_NAME" ] && [ -n "$FRONTEND_ECR_URL" ]; then
            REPO_NAME=$(echo "$FRONTEND_ECR_URL" | awk -F/ '{print $2}')
          fi
          if [ -z "$REPO_NAME" ]; then
            echo "No frontend ECR repository name provided; skipping creation. Set secret ECR_REPOSITORY_FRONTEND or ECR_REPO_URL_FRONTEND.";
          else
            aws ecr describe-repositories --repository-names "$REPO_NAME" --region ${{ secrets.AWS_REGION }} || aws ecr create-repository --repository-name "$REPO_NAME" --region ${{ secrets.AWS_REGION }}
            echo "FRONTEND_ECR_NAME=$REPO_NAME" >> $GITHUB_ENV
          fi
      - name: Resolve frontend ECR repository URI
        run: |
          if [ -n "$FRONTEND_ECR_NAME" ]; then
            REPO_URI=$(aws ecr describe-repositories --repository-names "$FRONTEND_ECR_NAME" --region ${{ secrets.AWS_REGION }} --query 'repositories[0].repositoryUri' --output text)
            echo "FRONTEND_IMAGE_URI=$REPO_URI" >> $GITHUB_ENV
          else
            echo "FRONTEND_IMAGE_URI=" >> $GITHUB_ENV
          fi
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: Build and push frontend Docker image
        env:
          FALLBACK_ECR_FRONT: ${{ secrets.ECR_REPO_FRONTEND }}
        run: |
          IMAGE_URI="$FRONTEND_IMAGE_URI"
          if [ -z "$IMAGE_URI" ]; then
            IMAGE_URI="$FALLBACK_ECR_FRONT"
          fi
          # final safe fallback: construct from account/region and a sane repo name
          if [ -z "$IMAGE_URI" ]; then
            if [ -n "${{ secrets.AWS_ACCOUNT_ID }}" ] && [ -n "${{ secrets.AWS_REGION }}" ]; then
              IMAGE_URI="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/cicd-final-frontend"
              echo "No explicit repo configured; using constructed ECR URI: $IMAGE_URI"
            fi
          fi
          if [ -z "$IMAGE_URI" ]; then
            echo "No FRONTEND_IMAGE_URI resolved and no fallback secret; building local image and skipping push.";
            docker build -t frontend:latest ./frontend
          else
            echo "Building and pushing image: $IMAGE_URI:latest"
            docker build -t "$IMAGE_URI:latest" ./frontend
            docker push "$IMAGE_URI:latest"
          fi

  terraform-validate:
    runs-on: ubuntu-latest
    needs: [push-backend, push-frontend]
    steps:
      - uses: actions/checkout@v4
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
      - name: Export AWS credentials
        run: |
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "AWS_DEFAULT_REGION=${{ secrets.AWS_DEFAULT_REGION }}" >> $GITHUB_ENV
      - name: Terraform Format
        run: terraform fmt -check -recursive
      - name: Terraform Validate
        run: terraform validate
      - name: Terraform Plan
        run: |
          cd infra/terraform
          terraform init
          terraform plan

  deploy-ec2:
    runs-on: ubuntu-latest
    needs: terraform-validate
    steps:
      - uses: actions/checkout@v4
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}
      - name: AWS Cleanup (remove duplicates)
        run: |
          pip install awscli
          # Remove duplicate IAM roles
          ROLES=$(aws iam list-roles --query "Roles[?RoleName=='ec2-app-role'].RoleName" --output text)
          for role in $ROLES; do
            aws iam delete-role --role-name $role || true
          done
          aws iam delete-instance-profile --instance-profile-name ec2-app-profile || true
          aws ec2 delete-key-pair --key-name FINALCICD || true
          # Remove excess VPCs if limit is reached (delete all non-default VPCs)
          VPCS=$(aws ec2 describe-vpcs --query 'Vpcs[?IsDefault==`false`].VpcId' --output text)
          for vpc in $VPCS; do
            aws ec2 delete-vpc --vpc-id $vpc || true
          done
          # Remove duplicate ELBv2 Load Balancer and Target Group
          LB_ARN=$(aws elbv2 describe-load-balancers --query "LoadBalancers[?LoadBalancerName=='ec2-app-alb'].LoadBalancerArn" --output text)
          if [ ! -z "$LB_ARN" ]; then
            aws elbv2 delete-load-balancer --load-balancer-arn $LB_ARN || true
          fi
          TG_ARN=$(aws elbv2 describe-target-groups --query "TargetGroups[?TargetGroupName=='ec2-app-tg'].TargetGroupArn" --output text)
          if [ ! -z "$TG_ARN" ]; then
            aws elbv2 delete-target-group --target-group-arn $TG_ARN || true
          fi
          # Remove duplicate Internet Gateways (delete all unattached IGWs)
          IGWS=$(aws ec2 describe-internet-gateways --query 'InternetGateways[?Attachments==`[]`].InternetGatewayId' --output text)
          for igw in $IGWS; do
            aws ec2 delete-internet-gateway --internet-gateway-id $igw || true
          done
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
      - name: Terraform Apply
        run: |
          cd infra/terraform
          terraform init
          terraform apply -auto-approve
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}