name: CI/CD Pipeline (Backend & Frontend → ECR → Terraform/EC2)

on:
  push:
    branches: [main]

concurrency:
  group: cicd-finalproject
  cancel-in-progress: true

jobs:
  test-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          cd backend
          npm ci

      - name: Run backend tests
        run: |
          cd backend
          npm test

      - name: Run backend coverage
        run: |
          cd backend
          npm run test:coverage

      - name: Upload backend coverage report
        uses: actions/upload-artifact@v4
        with:
          name: backend-coverage
          path: backend/coverage/

  push-backend:
    runs-on: ubuntu-latest
    needs: test-backend
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Ensure backend ECR repo exists (robust)
        env:
          ECR_URI:     ${{ secrets.ECR_REPO_BACKEND }}   # may be empty
          AWS_REGION:  ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          set -euo pipefail
          : "${AWS_REGION:?Missing AWS_REGION secret}"
          : "${AWS_ACCOUNT:?Missing AWS_ACCOUNT_ID secret}"

          if [ -n "${ECR_URI:-}" ]; then
            REPO_NAME="$(echo "$ECR_URI" | awk -F/ '{print $2}')"
          else
            REPO_NAME="cicd-final-backend"
            ECR_URI="${AWS_ACCOUNT}.dkr.ecr.${AWS_REGION}.amazonaws.com/${REPO_NAME}"
          fi

          if [ -z "${REPO_NAME}" ]; then
            echo "Failed to derive backend repo name. Check ECR_REPO_BACKEND or AWS_ACCOUNT_ID/AWS_REGION." >&2
            exit 1
          fi

          aws ecr describe-repositories --repository-names "$REPO_NAME" --region "$AWS_REGION" \
            || aws ecr create-repository --repository-name "$REPO_NAME" --region "$AWS_REGION"

          echo "BACKEND_IMAGE_URI=$ECR_URI" >> "$GITHUB_ENV"

      - name: ECR login (manual, retry)
        env:
          AWS_REGION:  ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          set -euo pipefail
          REGISTRY="${AWS_ACCOUNT}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          for i in 1 2 3 4 5; do
            if aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$REGISTRY"; then
              echo "ECR login OK"; break
            fi
            echo "ECR login failed (attempt $i)…"; sleep $((i*10))
            [ $i -eq 5 ] && { echo "ECR login failed after retries"; exit 1; }
          done

      - name: Build and push backend Docker image
        env:
          IMAGE_URI: ${{ env.BACKEND_IMAGE_URI }}
        run: |
          set -euo pipefail
          [ -z "${IMAGE_URI:-}" ] && { echo "BACKEND_IMAGE_URI is empty"; exit 1; }
          export DOCKER_BUILDKIT=1
          docker build -t "$IMAGE_URI:latest" ./backend
          for i in 1 2 3 4 5; do
            docker push "$IMAGE_URI:latest" && break
            echo "docker push failed (attempt $i)…"; sleep $((i*10))
            [ $i -eq 5 ] && { echo "push failed after retries"; exit 1; }
          done

  push-frontend:
    runs-on: ubuntu-latest
    needs: test-backend
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Ensure frontend ECR repo exists (robust)
        env:
          ECR_URI:     ${{ secrets.ECR_REPO_FRONTEND }}  # may be empty
          AWS_REGION:  ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          set -euo pipefail
          : "${AWS_REGION:?Missing AWS_REGION secret}"
          : "${AWS_ACCOUNT:?Missing AWS_ACCOUNT_ID secret}"

          if [ -n "${ECR_URI:-}" ]; then
            REPO_NAME="$(echo "$ECR_URI" | awk -F/ '{print $2}')"
          else
            REPO_NAME="cicd-final-frontend"
            ECR_URI="${AWS_ACCOUNT}.dkr.ecr.${AWS_REGION}.amazonaws.com/${REPO_NAME}"
          fi

          if [ -z "${REPO_NAME}" ]; then
            echo "Failed to derive frontend repo name. Check ECR_REPO_FRONTEND or AWS_ACCOUNT_ID/AWS_REGION." >&2
            exit 1
          fi

          aws ecr describe-repositories --repository-names "$REPO_NAME" --region "$AWS_REGION" \
            || aws ecr create-repository --repository-name "$REPO_NAME" --region "$AWS_REGION"

          echo "FRONTEND_IMAGE_URI=$ECR_URI" >> "$GITHUB_ENV"

      - name: ECR login (manual, retry)
        env:
          AWS_REGION:  ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          set -euo pipefail
          REGISTRY="${AWS_ACCOUNT}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          for i in 1 2 3 4 5; do
            if aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$REGISTRY"; then
              echo "ECR login OK"; break
            fi
            echo "ECR login failed (attempt $i)…"; sleep $((i*10))
            [ $i -eq 5 ] && { echo "ECR login failed after retries"; exit 1; }
          done

      - name: Build and push frontend Docker image
        env:
          IMAGE_URI: ${{ env.FRONTEND_IMAGE_URI }}
        run: |
          set -euo pipefail
          [ -z "${IMAGE_URI:-}" ] && { echo "FRONTEND_IMAGE_URI is empty"; exit 1; }
          export DOCKER_BUILDKIT=1
          docker build -t "$IMAGE_URI:latest" ./frontend
          for i in 1 2 3 4 5; do
            docker push "$IMAGE_URI:latest" && break
            echo "docker push failed (attempt $i)…"; sleep $((i*10))
            [ $i -eq 5 ] && { echo "push failed after retries"; exit 1; }
          done

  terraform-validate:
    runs-on: ubuntu-latest
    needs: [push-backend, push-frontend]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Export AWS credentials
        run: |
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ secrets.AWS_REGION }}" >> $GITHUB_ENV

      - name: Terraform Format (auto-fix)
        run: |
          cd infra/terraform
          terraform fmt -recursive

      - name: Terraform Validate
        run: |
          cd infra/terraform
          terraform init -backend=false -input=false
          terraform validate

      - name: Terraform Plan (non-fatal)
        run: |
          cd infra/terraform
          terraform init -input=false
          set +e
          terraform plan -no-color -detailed-exitcode -out=tfplan_validate
          code=$?
          set -e
          if [ $code -eq 0 ]; then
            echo "Plan: no changes."
          elif [ $code -eq 2 ]; then
            echo "Plan: changes detected (expected in validate stage)."
          else
            echo "Plan failed with exit code $code"; exit $code
          fi

  deploy-ec2:
  runs-on: ubuntu-latest
  needs: terraform-validate
  steps:
    - uses: actions/checkout@v4
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_wrapper: false
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    - name: Terraform Apply
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: ${{ secrets.AWS_REGION }}
      run: |
        cd infra/terraform
        terraform init
        terraform apply -auto-approve

